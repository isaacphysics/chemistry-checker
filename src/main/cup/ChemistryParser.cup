/**
 * Copyright 2016 James Sharkey
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 *
 * You may obtain a copy of the License at
 * 		http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.isaacphysics.labs.chemistry.checker;

import java.util.ArrayList;

terminal END, PLUS, MINUS, LPAREN, RPAREN;
terminal SingleArrow TO;
terminal DoubleArrow DTO;
terminal String STATE, ERROR;
terminal Integer NUMBER, CHARGE, SUP, SUB, WATER;
terminal String ELEMENT;
terminal ChemicalElectron C_ELECTRON;
terminal Nuclear ALPHA, BETA, GAMMA, NEUTRINO, P_ELECTRON, POSITRON, NEUTRON, PROTON;

non terminal ArrayList<Statement> result;
non terminal ArrayList<Statement> statement_list;
non terminal Statement statement;
non terminal Expression expr, n_expr, terms, n_terms;
non terminal Term term, n_term, end_term, n_end_term;
non terminal Isotope isotope, isotope_mod;
non terminal Molecule molecule;
non terminal Element element;
non terminal Compound compound, some_eb, b;
non terminal Nuclear nuclear;
non terminal Integer opt_number, charge;
non terminal String opt_state;

start with result;

/**
 * Non-terminal ArrayList<Statement> result:
 * The starting non-terminal. Reads a list of statement, separated by END token.
 * Result could end with an END token.
 */
result          ::=   statement_list:l                      {: RESULT = l; :}
                    | statement_list:l END                  {: RESULT = l; :}
                    ;

/**
 * Non-terminal ArrayList<Statement> statement_list:
 * Parses a list of statements separated by END tokens.
 */
statement_list  ::=   statement_list:l END statement:s      {: RESULT = l; RESULT.add(s); :}
                    | statement:s                           {: RESULT = new ArrayList<Statement>(); RESULT.add(s); :}
                    ;

/**
 * Non-terminal Statement statement:
 * Parses a statement. A statement could be in four forms:
 * 1. expr:             An expression that consists of only chemical terms.
 * 2. n_expr:           An expression that consists of only isotopes and other nuclear terms.
 * 3. expr TO expr:     A chemical equation.
 * 4. n_expr TO n_expr: A nuclear equation.
 */
statement       ::=   expr:e                                {: RESULT = new ExpressionStatement(e); :}
                    | n_expr:e                              {: RESULT = new NuclearExpressionStatement(e); :}
                    | expr:l TO:a expr:r                    {: RESULT = new EquationStatement(l, a, r); :}
                    | expr:l DTO:a expr:r                   {: RESULT = new EquationStatement(l, a, r); :}
                    | n_expr:l TO:a n_expr:r                {: RESULT = new NuclearEquationStatement(l, r); :}
                    ;

/**
 * Non-terminal Expression expr (expression):
 * Parses a chemical expression.
 *
 * A chemical expression consists of list of chemical terms, separated by PLUS.
 *
 * To avoid shift/reduce conflicts, PLUS are meld into chemical terms. So expression like
 * `K + Na+ + Cl- + Mg` should be read as `[(K+) (Na++) (Cl-+)] (Mg)`.
 *
 * The first 3 terms are regular terms, and the last term (without trailing PLUS) is called an end term.
 * Regular terms and end terms are parsed differently.
 */
expr            ::=   terms:e end_term:t                    {: RESULT = e; RESULT.add(t); :}
                    | terms:e error                         {: RESULT = e; RESULT.add(new ErrorTerm()); :}
                    | end_term:t                            {: RESULT = new Expression(t); :}
                    | error                                 {: RESULT = new Expression(new ErrorTerm()); :}
                    ;

/**
 * Non-terminal Expression terms:
 * Parses a list of chemical terms, where each term consists of a trailing PLUS.
 * Is rather intuitive.
 */
terms           ::=   terms:e term:t                        {: RESULT = e; RESULT.add(t); :}
                    | terms:e error                         {: RESULT = e; RESULT.add(new ErrorTerm()); :}
                    | term:t                                {: RESULT = new Expression(t); :}
                    | error                                 {: RESULT = new Expression(new ErrorTerm()); :}
                    ;

/**
 * Non-terminal Term term:
 * Parses a term. A term could be:
 * 1. An ion, i.e. charged molecule.
 * 2. An uncharged molecule.
 * 3. A hydrate.
 * 4. Electrons.
 *
 * The parsing considers all possibilities mentioned above, and reads the trailing PLUS as well.
 * The code may look messy, but I cannot further simplify terms.
 * Further simplifications introduce shift/reduce conflicts.
 */
term            ::=   opt_number:n molecule:m charge:c opt_state:s PLUS
                                                            {: RESULT = new Term(n, new Ion(m, c), s); :}
                    | opt_number:n molecule:m PLUS
                                                            {: RESULT = new Term(n, m, null); :}
                    | opt_number:n molecule:m STATE:s PLUS  {: RESULT = new Term(n, m, s); :}
                    | opt_number:n compound:c WATER:w opt_state:s PLUS
                                                            {: RESULT = new Term(n, new Hydrate(c, w), s); :}
                    | opt_number:n C_ELECTRON:e PLUS        {: RESULT = new Term(n, e, null); :}
                    ;

/**
 * Non-terminal Term end_term (ending term):
 * Parses an ending term.
 * The parsing is done similar to non-terminal term, but without the trailing PLUS.
 */
end_term        ::=   opt_number:n molecule:m charge:c opt_state:s
                                                            {: RESULT = new Term(n, new Ion(m, c), s); :}
                    | opt_number:n molecule:m opt_state:s
                                                            {: RESULT = new Term(n, m, s); :}
                    | opt_number:n compound:c WATER:w opt_state:s
                                                            {: RESULT = new Term(n, new Hydrate(c, w), s); :}
                    | opt_number:n C_ELECTRON:e             {: RESULT = new Term(n, e, null); :}
                    ;

/**
 * Non-terminal Expression n_expr (nuclear expression):
 * Parses a list of nuclear terms (n_term).
 *
 * Similar to non-terminal expr, PLUS-es are bound to the term to the left.
 * Therefore expressions like `\gamma_ray + ^{43}_{32}X + ^{74}_{53}Y` should be read as:
 * `[(\gamma_ray+) (^{43}_{32}X+)] (^{74}_{53}Y)`,
 * where first 2 terms belong to n_terms, and last term is called a nuclear ending term.
 */
n_expr          ::=   n_terms:e n_end_term:t                {: RESULT = e; RESULT.add(t); :}
                    | n_terms:e error                       {: RESULT = e; RESULT.add(new ErrorTerm()); :}
                    | n_end_term:t                          {: RESULT = new Expression(t); :}
                    ;

/**
 * Non-terminal Expression n_terms (nuclear terms):
 * Parses a list of nuclear terms (n_term) with trailing PLUS.
 * The code is rather straightforward.
 */
n_terms         ::=   n_terms:e n_term:t                    {: RESULT = e; RESULT.add(t); :}
                    | n_terms:e error                       {: RESULT = e; RESULT.add(new ErrorTerm()); :}
                    | n_term:t                              {: RESULT = new Expression(t); :}
                    ;

/**
 * Non-terminal Term n_term (nuclear term):
 * Parses a single nuclear term with trailing PLUS.
 * A nuclear term is either an isotope, or a special term like /alpha_particle.
 */
n_term          ::=   isotope:i                             {: RESULT = new Term(1, i, null); :}
                    | opt_number:n nuclear:e PLUS           {: RESULT = new Term(n, e, null); :}
                    ;

/**
 * Non-terminal Isotope isotope:
 * Parses an isotope. An isotope consists of four parts:
 * 1. Subscripted SUB:   The atomic number.
 * 2. Superscripted SUP: The mass number.
 * 3. Element ELEMENT:   The relevant element.
 * 4. Optional charge:   Charge of the isotope.
 *
 * One might notice that the parsing includes trailing plus symbol.
 * This is to prevent shift/reduce conflicts in LALR(1) parser.
 */
isotope         ::=   SUP:sup SUB:sub ELEMENT:e PLUS        {: RESULT = new Isotope(sup, sub, new Element(e, 1)); :}
                    | SUB:sub SUP:sup ELEMENT:e PLUS        {: RESULT = new Isotope(sup, sub, new Element(e, 1)); :}
                    | SUP:sup SUB:sub ELEMENT:e charge:c PLUS
                                                            {: RESULT = new Isotope(sup, sub,
                                                                                    new Ion(new Element(e, 1), c)); :}
                    | SUB:sub SUP:sup ELEMENT:e charge:c PLUS
                                                            {: RESULT = new Isotope(sup, sub,
                                                                                    new Ion(new Element(e, 1), c)); :}
                    ;

/**
 * Non-terminal Term n_end_term (nuclear ending term):
 * Parses the last nuclear term in an expression. Could either be an isotope,
 * or special nuclear particles without trailing plus.
 */
n_end_term      ::=   isotope_mod:i                         {: RESULT = new Term(1, i, null); :}
                    | opt_number:n nuclear:e                {: RESULT = new Term(n, e, null); :}
                    ;

/**
 * Non-terminal Isotope isotope_mod (modified isotope):
 * Parses the isotope at the end of an expression.
 * Very similar to non-terminal isotope, but with trailing PLUS removed.
 */
isotope_mod     ::=   SUP:sup SUB:sub ELEMENT:e             {: RESULT = new Isotope(sup, sub, new Element(e, 1)); :}
                    | SUB:sub SUP:sup ELEMENT:e             {: RESULT = new Isotope(sup, sub, new Element(e, 1)); :}
                    | SUP:sup SUB:sub ELEMENT:e charge:c    {: RESULT = new Isotope(sup, sub,
                                                                                    new Ion(new Element(e, 1), c)); :}
                    | SUB:sub SUP:sup ELEMENT:e charge:c    {: RESULT = new Isotope(sup, sub,
                                                                                    new Ion(new Element(e, 1), c)); :}
                    ;

/**
 * Non-terminal Nuclear nuclear:
 * Parses special nuclear particles like ALPHA, BETA. It is rather straightforward.
 */
nuclear         ::=   ALPHA:e                               {: RESULT = e; :}
                    | BETA:e                                {: RESULT = e; :}
                    | GAMMA:e                               {: RESULT = e; :}
                    | NEUTRINO:e                            {: RESULT = e; :}
                    | P_ELECTRON:e                          {: RESULT = e; :}
                    | POSITRON:e                            {: RESULT = e; :}
                    | NEUTRON:e                             {: RESULT = e; :}
                    | PROTON:e                              {: RESULT = e; :}
                    ;

/**
 * Non-terminal Molecule molecule:
 * Parse a molecule. A molecule is either an element or a compound, and both have very different ways of parsing.
 * See annotations for non-terminals element and compound for more details.
 */
molecule        ::=   element:e                             {: RESULT = e; :}
                    | compound:c                            {: RESULT = c; :}
                    ;

/**
 * Non-terminal Element element:
 * Parses an element. An element could be in form:
 * 1. ELEMENT        (e.g. Na)
 * 2. ELEMENT NUMBER (e.g. Na3)
 * 3. ELEMENT SUB    (e.g. Na_{3})
 */
element         ::=   ELEMENT:e opt_number:n                {: RESULT = new Element(e, n); :}
                    | ELEMENT:e SUB:n                       {: RESULT = new Element(e, n); :}
                    ;

/**
 * Non-terminal Compound compound:
 * Parses a compound. A compound is either:
 * 1. Something that consists of two or more elements (e.g. NaCl). Let element term be E.
 * 2. A thing with brackets, where bracketed term is compound. (e.g. Na(HCO)3). Let bracketed term be B.
 *
 * So, regular expression of compound would be B(E|B)* | E(E|B)+. The following grammar simulates such expression.
 */
compound        ::=   b:b some_eb:eb                        {: RESULT = new Compound(b); RESULT.addCompound(eb); :}
                    | element:e1 element:e2 some_eb:eb      {: RESULT = new Compound(e1); RESULT.add(e2);
                                                               RESULT.addCompound(eb); :}
                    | element:e b:b some_eb:eb              {: RESULT = new Compound(e); RESULT.add(b);
                                                               RESULT.addCompound(eb); :}
                    ;

/**
 * Non-terminal Compound some_eb:
 * Parses (E|B)* part of a compound. See annotations of non-terminal compound for more details.
 */
some_eb         ::=                                         {: RESULT = new Compound(null); :}
                    | some_eb:e element:elem                {: RESULT = e; RESULT.add(elem); :}
                    | some_eb:e b:b                         {: RESULT = e; RESULT.add(b); :}
                    ;

/**
 * Non-terminal Compound b:
 * Parses bracketed terms (B) of a compound. See annotations of non-terminal compound for more details.
 */
b               ::=   LPAREN compound:c RPAREN NUMBER:n     {: RESULT = c; RESULT.setNumber(n); :}
                    ;

/**
 * Non-terminal Integer opt_number (optional number):
 * Coefficients of chemical formulae.
 * Returns 1 if optional number not specified (e.g. Coefficient of Na = 1.)
 */
opt_number      ::=   NUMBER:n                              {: RESULT = n; :}
                    |                                       {: RESULT = 1; :}
                    ;
/**
 * Non-terminal String opt_state (optional state):
 * Parses the 'state' part of a chemical formula. (e.g. (aq), (s), ...)
 * Returns null if state is not specified.
 */
opt_state       ::=   STATE:s                               {: RESULT = s; :}
                    |                                       {: RESULT = null; :}
                    ;
/**
 * Non-terminal Integer charge:
 * Parses the charge of a chemical formula.
 * Formula like molecule CHARGE:c has charge of c.
 * molecule PLUS has charge of 1, and molecule MINUS has -1.
 */
charge          ::=   CHARGE:c                              {: RESULT = c; :}
                    | PLUS                                  {: RESULT = 1; :}
                    | MINUS                                 {: RESULT = -1; :}
                    ;